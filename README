mininasm: NASM-compatible mini assembler for 8086, able to run on DOS and on
modern systems
^^^^^^^^^^^^^^
mininasm is a minimalistic NASM-compatible assembler targeting the Intel
8086 (and 8088). It's implemented in C, and it can be compiled to DOS
(targeting 8086) and to modern systems.

mininasm is based on https://github.com/nanochess/tinyasm , with the
following improvements:

* It supports 32-bit numbers. (However, it doesn't support the 32-bit
  or 64-bit instructions, and it can't generate 32-bit DOS programs.)
* `bits 16' works.
* `cpu 186' and `cpu 286' also work. (For the 286, it supports all
  instructions except for those related to protected mode.)
  This hasn't been implemented yet.
* It supports 287 floating point instructions.
  This hasn't been implemented yet.
* It supports `%define MACRO VALUE'. (It doesn't support macros with
  arguments or multiline macros.)
  This hasn't been implemented yet.
* Its output (stderr, output file, listing file) doesn't depend on the host,
  not even for integer overflow (e.g. number of bytes reported), this it's a
  true cross-assembler.
* When compiled for DOS, it uses memory with efficiently, and thus it is able
  to compile an assembly inpout file with >55000 labels (see the file
  most.asm). Most other 16-bit DOS assemblers support less than 8000 labels
  (e.g. A86 4.05 supports ~7200 labels, TASM 4.1 supports ~7400 labels,
  MASM 5.10a supports ~11800 labels, NASM 0.98.39 lite supports ~8000 labels).
* It depends on fewer runtime (libc) functions, so it can be compiled to a
  DOS .com file smaller than Tinyasm.
  Savings: about 17.1 KiB .com program instead of 30 KiB .com program
  with `owcc -bcom -Os'.
* Its behavior is adjusted for better compatibility with NASM 0.98.39.
  The most important difference is that it supports 16-bit numbers, but
  NASM 0.98.39 supports 32-bit numbers. See more differences between
  mininasm and NASM below.
* Its stack use has a constant upper bound (e.g. no recursive function
  calls), it never crashes because of large input.
* It has some new (NASM-compatible) features such as 'multicharacter' string
  literals, the unary `~' operator, 0o... octal integer literal syntax.
* The `>>', `/', `//', `%' and `%%' operators have a deterministic behavior
  (matching NASM on the i386) no matter what the host system architecture is.
  This is also an improvement over NASM.

Differences between mininasm and NASM:

* There is only support for 8086/8088 processors (bits 16, cpu 8086), no
  later 16-bit instructions (cpu 186; cpu 286), no 8087 floating point
  instructions, no 32-bit instructions (bits 32, in protected mode), no 64-bit
  instructions (bits 64, in long mode).

* Label definitions without (a leading `$' or a trailing `:') are supported
  only for `equ', `db', `dw' and `dd'.

* All label values are integers, there are no section-relative values. This
  makes mininasm more permissive, e.g. `db $ * 3' works in mininasm, but
  only `db ($ - $$) * 3' works in NASM, because `$' is section-relative in
  NASM.

* Only the following directives are supported:

        %define
        %assign
        %undef
	%ifdef
	%ifndef
	%if
	%else
	%endif
	%include
	incbin
	times
	use16
	bits 16
	cpu 8086
	equ
	db
	dw
	dd
	align
	resb

* Single-line macros (e.g. with `%define' and `%assign') must have an
  integer value (only integer literals and unarhy `+', `-' and `~' are
  supported), and most not take any macro arguments.

* Macros defined in the command line cannot be changed or undefined.

* A macro and a label must not have the same name, except if the
  macro is defined to itself as `%define NAME NAME'.

* Multiline macros (e.g. `macro' and `endm') are not supported.

* Comparison operators (e.g. `==') and logical operators (e.g. `&&') are not
  supported in `%if' expressions.

* Source lines longer than 255 bytes (not counting the trailing whitespace +
  optional comment + LF line terminator) are not allowed.

* mininasm reports an error for some register operations of the wrong size
  (e.g. `dec byte bx' and `dec word bh'), while NASM reports only a warning.

* mininasm silently works correctly if the integer argument of `align' is
  not a power of 2.

* `section' definitions are not supported, except for
  `section .bss align=1'. Just like in NASM, .bss is case sensitive.
  In mininasm it's not possible to switch back to `section .text', but
  in NASM it is.

* If the input file is at least 2 GiB long, and it contains an `%include',
  then it may get processed incorrectly.

Similarities with NASM:

* Local labels are supported, and should start with period.
  The local labels final name is derived from concatenation
  of the last global label (not starting with period) and
  the local label.

The following operators are implemented:

	|	Bitwise OR
	^	Bitwise XOR
	&	Bitwise AND
	~	Unary bitwise NOT
	<<	Shift to left
	>>	Shift to right
	+	Addition
	-	Subtraction
	* 	Multiplication
	/	Division (unsigned 16-bit)
	%	Modulo operator
	(expr)	Parenthesis
	-	Unary negation
        +       Unary addition (no-op).

The following numbers are implemented:

	0b0000_0100	Binary, you can use underscore (it will be ignored)
	0xabcd		Hexadecimal.
	0o123		Octal.
	$0abcd		Hexadecimal (after $ the first digit must be a number)
	'a'		Character constant.
	10		Decimal.
	$$		Start address.
	$		Current address.

For compatibility, the mininasm repository also contains tinasm (source
code: tinasm.c), which aims to be compatible with Tinyasm, with the
following changes:

* Critical bugfixes: tinasm works when Tinyasm crashes or generates
  incorrect code.
* Portability improvements (to more systems and C and C++ compilers).
* Deterministic cross-compilation using dosmc.
* Its stack use has a constant upper bound (e.g. no recursive function
  calls), it never crashes because of large input.
* Numbers are always 16-bit, no matter the host system.
* Its output (stderr, output file, listing file) doesn't depend on the host,
  not even for integer overflow (e.g. number of bytes reported), this it's a
  true cross-assembler.
* On DOS, it can use more than ~20 KiB memory (up to ~595 KiB) for labels,
  when compiled with the OpenWatcom C compilar with the compact memory
  model.
* The `%' and `/' operators treat their inputs as unsigned integers
  consistently. (In Tinyasm, only `%' is signed.)
* (Otherwise, tinasm should behave identically to Tinyasm.)

The mininasm repository also contains minnnasm (source code:
https://github.com/pts/mininasm/blob/master/minnnasm.nasm),
which is a full-featured self-hosting fork of mininasm for DOS 8086 only,
implemented in a subset of NASM assembly language, thus it's able to compile
(assemble) itself on DOS: by doing so it produces a DOS .com executable
binary bit-by-bit identical to what is produced by NASM (>= 0.98.39) and
mininasm (https://github.com/pts/mininasm). One of the development goals of
minnnasm is to improve the compatibility of mininasm with NASM: it's source
code is relatively complex NASM-compatible assembly code.

Info about other assemblers:

* x86 assembler and linker comparison: https://pmwiki.xaver.me/drdoswiki/index.php?n=Main.DevelAsm

* x86 assembler comparison: https://www.japheth.de/JWasm/AsmCmp.html

* PC-72 assembler A72 a72.com: https://github.com/swanlizard/a72

  Discussion: https://www.bttr-software.de/forum/board_entry.php?id=17005

  Open source, tiny, can create .com and .bin only.

  A 8086 assembler without bells, whistles, gongs, or macros. It's a
  bare-bones single-segment symbolic assembler that will take standard
  Intel-format assembly and turn it into a COM file executable under DOS.
  R.Swan writes: "I wrote it for my own sake because I wanted to write
  assembly without having to use a bunch of directives and extraneous garbage
  in order to even just start writing, and to have binary code I could fully
  control and predict." Released to the public domain.

* Some other assemblers (source and binary download) targeting DOS:
  http://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/devel/asm/

* Many more assemblers listed here:
  https://board.flatassembler.net/topic.php?t=5949

* JWasm is an assembler compatible with MASM v6.

  Latest JWasm releases (v2.16pre2 on 2022-07-28):
  https://github.com/Baron-von-Riedesel/JWasm/releases

Known self-hosting assemblers (i.e. those which can compile their own assembly
source code) for x86:

* FASM: https://flatassembler.net/

* Asmc: https://github.com/nidud/asmc

* LZASM (closed source):
  http://web.archive.org/web/20071024143102/http://lzasm.hotbox.ru/

* A86 (closed source): https://eji.com/a86/

* NGSAM (closed source): http://www.bestdiskrecovery.com/ (link broken),
  http://www.bestdiskrecovery.com/ngasm/index.html (link broken)

* A72: https://github.com/swanlizard/a72

* Venski assembler:
  http://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/devel/asm/venksi/

* Wolfware Assembler:
  http://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/devel/asm/wasm/mitlicense/

* minnnasm.nasm in mininasm:
  https://github.com/pts/mininasm/blob/master/minnnasm.nasm

* TMA:
  https://www.sac.sk/download/utilprog/ta980705.zip
  https://www.sac.sk/download/utilprog/ta980717.zip

* intasm == intelasm == Intel Assembler:
  http://exmortis.narod.ru/comp_src/intasm52.zip

* XASM:
  https://www.sac.sk/download/utilprog/xasm312.zip
  https://web.archive.org/web/20070823101949/http://xasm.webpark.pl/xasm/files/xasm312.zip
  https://web.archive.org/web/20060813152752/http://xasm.webpark.pl/xasm/files/xasm2pde.zip

  Both XASM 3.x and 2.x are self-hosting. The source code of XASM 2.3 has been
  released along with the binary in xasm2pde.zip.

* Rosasm by Ren√© Tournois (Betov): (all download links dead)

  Runs on Win32, targets Win32 (32 bits). IDE only, no command-line.

Not self-hosting assemblers:

* NASM (open source, written in C).

* YASM (open source, written in C).

* WASM (open source, written in C).

* JWasm (open source, written in C).

* vasm (open source, written in C).

Below is a copy of the README of Tinyasm.

,--------.,--.
'--.  .--'`--',--,--, ,--. ,--.,--,--. ,---. ,--,--,--.
   |  |   ,--.|      \ \  '  /' ,-.  |(  .-' |        |
   |  |   |  ||  ||  |  \   ' \ '-'  |.-'  `)|  |  |  |
   `--'   `--'`--''--'.-'  /   `--`--'`----' `--`--`--'
                      `---'
Tinyasm 8086/8088 assembler
by Oscar Toledo G. Oct/02/2019

https://nanochess.org/
https://github.com/nanochess/tinyasm

Tinyasm is a small assembler for 8086/8088 programs,
and it can work over a real PC XT machine. It requires
at least 128K of memory, maybe more.

It came to my attention that several people wanted to
assemble my boot sector games over real PC XT machines.

Unfortunately, nasm doesn't run over 8086/8088 processors,
and I couldn't find a compatible assembler!

So what does a programmer when doesn't find the required
tool? Start to code his own tool!

It took me 3 days to start from zero and get a working
assembler compatible with the nasm syntax, plus all the
directives I've used in my boot sector programs.

Using the same command line syntax as nasm:

  tinyasm -f bin rogue.asm -o rogue.img -l rogue.lst

There is also the -d option for defining labels:

  -dCOM_FILE
  -dCOM_FILE=1

It returns a non-zero error code when the assembled
file generates errors.

Thanks to tkchia for making it portable to ia16-elf-gcc,
removing DeSmet C warnings, and making it to return
error codes.

Thanks to humbertocsjr for contributing the INCBIN
command.


This assembler won't win a speed test ;) because the
internal implementation uses a linear search for the
instruction set, and it is also implemented as a kind
of regular expression subset for easier coding.


>> DEBUG NOTES <<

If you're building boot sector games with Tinyasm, then you
need the following info to load the game inside the boot
sector of a floppy disk.

You need to have DEBUG in your disk (included with the DOS
disks).

Do the following (replace filename as desired):

	DEBUG ROGUE.IMG
		Extract now your working disk and insert a blank one!!!
	A300
	MOV AX,0301
	MOV BX,0100
	MOV CX,1
	MOV DX,0
	INT 13
	JB 300
	INT 20
	RIP
	300
	G
		Now the boot sector is replaced with the program!!!


>> BUILDING THE ASSEMBLER >>

You can build your own executable for Tinyasm using the
C compiler Desmet C, version 3.1h available graciously at:

    http://www.desmet-c.com/

The compiler has many bugs and limitations, but it works for
Tinyasm purposes, and it's freely available.

Supposedly it should support ANSI C, but I couldn't fit a
standard ANSI C function definition, so I had to code again
in C K&R for the first time in maybe 20 years!

You can find the "e.bat" file to assemble the compiler.

I provide an executable on the Git to save you some time.

There are test cases in the 'test' subdirectory that are
runnable with the "test.bat" file.

There is a test for the full instruction set of 8086/8088
(the same listing that appears in my book Programming Boot
Sector Games).

The test cases come from my own programs:

	https://github.com/nanochess/fbird
	https://github.com/nanochess/invaders
	https://github.com/nanochess/pillman
	https://github.com/nanochess/bootBASIC
	https://github.com/nanochess/bootOS
	https://github.com/nanochess/bootRogue


>> ATTENTION <<

Would you like to learn 8086/8088 programming? Then you
must get my new book Programming Boot Sector Games including
a 8086/8088 crash course!

Now available from Lulu:

  Soft-cover
    http://www.lulu.com/shop/oscar-toledo-gutierrez/programming-boot-sector-games/paperback/product-24188564.html

  Hard-cover
    http://www.lulu.com/shop/oscar-toledo-gutierrez/programming-boot-sector-games/hardcover/product-24188530.html

  eBook
    https://nanochess.org/store.html

These are some of the example programs documented profusely
in the book:

  * Guess the number.
  * Tic-Tac-Toe game.
  * Text graphics.
  * Mandelbrot set.
  * F-Bird game.
  * Invaders game.
  * Pillman game.
  * Toledo Atomchess.
  * bootBASIC language.

After the success of my first book, if you need even
More Boot Sector Games then you must get this book!

  Soft-cover
    http://www.lulu.com/shop/oscar-toledo-gutierrez/more-boot-sector-games/paperback/product-24462035.html

  Hard-cover
    http://www.lulu.com/shop/oscar-toledo-gutierrez/more-boot-sector-games/hardcover/product-24462029.html

These are some of the example programs documented profusely
in the book:

  * Follow the Lights
  * bootRogue
  * bricks
  * cubicDoom
  * bootOS
